<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="const的不同用法"><meta name="keywords" content=""><meta name="author" content="Pan Wong"><meta name="copyright" content="Pan Wong"><title>const的不同用法 | Wong's blog</title><link rel="shortcut icon" href="/sad_face.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c中的const"><span class="toc-number">1.</span> <span class="toc-text"> C中的const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#默认状态下const对象在文件内有效"><span class="toc-number">1.0.0.1.</span> <span class="toc-text"> 默认状态下，const对象在文件内有效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对const的引用"><span class="toc-number">1.0.0.2.</span> <span class="toc-text"> 对const的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针和const"><span class="toc-number">1.0.0.3.</span> <span class="toc-text"> 指针和const</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顶层const"><span class="toc-number">1.1.</span> <span class="toc-text"> 顶层const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr限定符"><span class="toc-number">1.1.0.1.</span> <span class="toc-text"> constexpr限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型别名和const"><span class="toc-number">1.1.0.2.</span> <span class="toc-text"> 类型别名和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const形参和实参"><span class="toc-number">1.1.0.3.</span> <span class="toc-text"> const形参和实参</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c中的const-2"><span class="toc-number">2.</span> <span class="toc-text"> C++中的const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类初始化"><span class="toc-number">2.0.0.1.</span> <span class="toc-text"> 类初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const成员函数"><span class="toc-number">2.0.0.2.</span> <span class="toc-text"> const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const和函数重载"><span class="toc-number">2.0.0.3.</span> <span class="toc-text"> const和函数重载</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">Pan Wong</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/moon.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Wong's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">const的不同用法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/C/">C++</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 6 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><code>const</code>表示的是常量属性，被<code>const</code>修饰的内容不可被改变。在定义一个<code>const</code>的对象时需要在构造时进行初始化，并且包含了<code>const</code>成员的类并不会生成默认的拷贝构造函数和拷贝复制运算符，因为默认的拷贝构造函数是逐个成员进行赋值，而<code>const</code>不允许这样做。<code>const</code>有很多的知识点，大多零碎的分布在各种地方，这篇文章主要是帮助自己整理出来，方面日后。</p>
<h1 id="c中的const"><a class="markdownIt-Anchor" href="#c中的const"></a> C中的const</h1>
<p>在这里讨论的<code>const</code>限定符规则同样适用于C++，但是这里不会讨论关于类内，重载等的情况。</p>
<h4 id="默认状态下const对象在文件内有效"><a class="markdownIt-Anchor" href="#默认状态下const对象在文件内有效"></a> 默认状态下，const对象在文件内有效</h4>
<p>这样的定义会出现一种情况，就是在多个文件中需要使用到这个对象时，会出现重复定义一个对象的情况，解决办法是使用<code>extern</code>在声明和定义时加入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// file_1.cc</span><br><span class="line">extern const int bufSize = fcn();</span><br><span class="line"></span><br><span class="line">// file_1.h</span><br><span class="line">extern const int bufSize;</span><br></pre></td></tr></table></figure>
<p>上面.cc文件中是一次定义，而在.h文件中的声明表明，bufSize这个对象的定义会在别处出现，这样就可以在文件之间共享一个const对象了。在定义的时候加入extern是必须的</p>
<h4 id="对const的引用"><a class="markdownIt-Anchor" href="#对const的引用"></a> 对const的引用</h4>
<p>想要引用一个常量，这个引用对象必须也是一个常量，这点是比较容易理解的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line"></span><br><span class="line">const int &amp;r1 = ci;//正确</span><br><span class="line"></span><br><span class="line">r1 = 42//错误， r1是一个常量，无法改变</span><br><span class="line"></span><br><span class="line">int &amp;r2 = ci // 错误，非常量引用指向一个常量对象</span><br></pre></td></tr></table></figure>
<p>注意，引用的类型必须与其所引用对象的类型一样，因为不一样的话最后引用绑定到的是一个临时对象而已。</p>
<h4 id="指针和const"><a class="markdownIt-Anchor" href="#指针和const"></a> 指针和const</h4>
<p>指向常量的指针(pointer to const)，指针可以重新指向其他的常量，但是不能改变所指常量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const int pi = 1;</span><br><span class="line">const int* cptr = &amp;pi;</span><br><span class="line">*cptr = 42; //错误，不能改变常量</span><br><span class="line"></span><br><span class="line">int pr = 1;</span><br><span class="line">const int* cptr2  = &amp;pr; //可以指向一个非常量对象</span><br></pre></td></tr></table></figure>
<p>常量指针(const pointer)，这个指针是一个常量，所以指针不能重新指，需要定义时进行初始化，将const放在星号后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int errNumb = 0;</span><br><span class="line">int *const curErr = &amp;errNumb;//curErr是一个指向变量的常量指针</span><br><span class="line"></span><br><span class="line">const int pi = 3;</span><br><span class="line">const int *const pip = &amp;pi; //pip是一个指向常量的常量指针</span><br></pre></td></tr></table></figure>
<p>常量指针：指针本身是常量，不允许改变指向。<br />
指向常量的指针：指针本身可以改变指向，指向的对象是常量，不允许改变。</p>
<h2 id="顶层const"><a class="markdownIt-Anchor" href="#顶层const"></a> 顶层const</h2>
<p>由于指针本身就是一个对象，而它又可以指向一个对象，所以指针本身是不是常量以及指针所指的是不是一个常量就是两个独立的问题，一般使用顶层const表明指针本身是不是常量，而使用底层const表示指针所指的对象是一个常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *const p1 = &amp;i; //不能改变p1的值，是一个顶层const</span><br><span class="line">const int ci = 42; //不能改变ci的值，是一个顶层const</span><br><span class="line">const int *p2 = &amp;ci; //允许改变p2的值，是一个底层const</span><br></pre></td></tr></table></figure>
<p>在进行拷贝的时候，顶层const不受影响，因为拷贝操作不会改变被拷贝对象的值，而拷贝操作的对象必须具有相同的底层const资格。</p>
<h4 id="constexpr限定符"><a class="markdownIt-Anchor" href="#constexpr限定符"></a> constexpr限定符</h4>
<p>constexpr 关键字使得代码在编译过程中，如果编译器对于某个表达式已经得到足够多的信息，那么编译器会在编译器一结束就把该表达式的结果求出来。即对于无 constexpr 关键字的表达式是在运行期执行，对于有 constexpr 关键字的表达式是在编译期执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fact(int n) &#123;</span><br><span class="line">	return (n == 1 ? 1 : n * fact(n - 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constexpr int fact_const(int n) &#123;</span><br><span class="line">	return (n == 1 ? 1 : n * fact_const(n - 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int ac, char* av[]) &#123;</span><br><span class="line">	int arr1[fact(4)];		// 错误，数组大小不确定</span><br><span class="line">	int array2[fact_const(4)];	//@1 正确。等价于写了 4 * 3 * 2</span><br><span class="line">	char group[fact_const(6)];	//@2 正确</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型别名和const"><a class="markdownIt-Anchor" href="#类型别名和const"></a> 类型别名和const</h4>
<p>在使用<code>typedef</code>定义的类型别名的时候，不能简单的替换之后进行理解，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef char *pstring;</span><br><span class="line"></span><br><span class="line">const pstring cstr = 0; //指向char的常量指针</span><br><span class="line"></span><br><span class="line">const pstring *ps; // ps是一个指针，其指向的值是一个指向char的常量指针</span><br></pre></td></tr></table></figure>
<p>如果只是进行简单的替换<code>const char *cstr</code>就成了一个指向const char的指针了。因为在pstring中，其数据类型是指针，而替换之后，类型就变成了char，星号变成了声明符的一部分。</p>
<h4 id="const形参和实参"><a class="markdownIt-Anchor" href="#const形参和实参"></a> const形参和实参</h4>
<p>当形参是const时，需要注意，顶层的const是修饰的对象本身，当用实参初始化形参的时候会忽略掉顶层const，所以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void fcn(const int i)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>函数既可以传入const int 也可以传入int，形参会忽略顶层const产生的一种后果是重载函数时，参数有无const并不能作为重载函数的依据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void fcn(const int i)</span><br><span class="line">void fcn(int i)</span><br></pre></td></tr></table></figure>
<p>因为忽略了顶层的const，所以上面两个函数在传入int类型的时候都会被调用，所以无法使用const作为参数上的差异了，但是函数可以定义为const进行重载。</p>
<hr />
<h1 id="c中的const-2"><a class="markdownIt-Anchor" href="#c中的const-2"></a> C++中的const</h1>
<p>上面提到了每一个点，在C++ 中同样适用，但是因为面向对象特性和const的结合，C++有更多需要注意的地方。</p>
<h4 id="类初始化"><a class="markdownIt-Anchor" href="#类初始化"></a> 类初始化</h4>
<p>如果类中包含了const成员对象，1.需要在构造函数初始化列表中进行初始化；2.不会生成默认的拷贝构造函数和赋值运算符、移动构造函数和移动赋值运算符。这些都是显而易见的，当一个类中包含了const对象或者引用对象时，在创建时就必须进行初始化了，而且由于const和引用都无法进行改变，默认的构造函数也不会生成。</p>
<h4 id="const成员函数"><a class="markdownIt-Anchor" href="#const成员函数"></a> const成员函数</h4>
<p>当一个类中的成员函数被const修饰的时候，表明了在该函数内，不会改变对象的成员变量，<strong>我们知道在类中的成员函数中会隐形传递一个this指针，而在const成员函数中，这个指针就会变成增加一个底层const使得this无法被改变。注意const在函数中的位置，如果放在前面的话修饰的是函数的返回值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const string&amp; func()&#123;return &quot;ABC&quot;;&#125;</span><br><span class="line"></span><br><span class="line">string&amp; func() const &#123;string a;return a;&#125;</span><br></pre></td></tr></table></figure>
<p>有一种例外，就是在使用<code>mutable</code>修饰的成员对象上，const成员函数也可以对进行修改操作。</p>
<h4 id="const和函数重载"><a class="markdownIt-Anchor" href="#const和函数重载"></a> const和函数重载</h4>
<p>可以依据函数是否有const修饰来进行重载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Screen&#123;</span><br><span class="line">  public:</span><br><span class="line">    Screen &amp;display(std::ostream &amp;os)&#123;</span><br><span class="line">      do_display(os);</span><br><span class="line">      return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Screen &amp;display(std::ostream &amp;os) const&#123;</span><br><span class="line">      do_display(os);</span><br><span class="line">      return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    void do_display(std::ostream &amp;os) const&#123;</span><br><span class="line">      os &lt;&lt; contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上诉类会根据调用对象的是否是常量来调用相应版本，非常量版本的display调用do_display()时，this指针隐式传递过去并转换成指向常量的指针。当do_display()完成之后，display()函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此返回一个普通的引用，而const成员函数则返回一个常量引用。</p>
<hr />
<p>#结语<br />
以上就是const在使用的时候不同地方不同的方法，后续会进行补充。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Pan Wong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://panpanpan.wang/2020/02/02/const%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/">https://panpanpan.wang/2020/02/02/const%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://panpanpan.wang">Wong's blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/02/01/%E8%99%9A%E6%9E%84%E6%8E%A8%E7%90%86%E8%A7%82%E5%90%8E%E6%84%9F/"><span>虚构推理观后感</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/moon.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Pan Wong</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>